//
//  main.m
//  数组
//
//  Created by niit on 15/12/18.
//  Copyright © 2015年 NIIT. All rights reserved.
//

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool
    {
        
//#pragma mark - 数组 一组相同类型的数据
//        int a[5];// 5个元素的数组
//        //通过下标进行访问数组元素a[i] i=0~4 第一个元素是a[0]
//        a[0]=10;
//        a[1]=20;
//        a[2]=30;
//        a[3]=40;
//        a[4]=50;
//        
//        // 定义数组的时候给数组赋初值
//        int b[5] = {10,20,30,40,50};
//        int c[5] = {10,20,30};// 没有被初始化的元素值是0
////        int d[5] = {10,20,30,40,50,60};// 错误,超出数组长度
//        
//        // 例:
//        char words[] = {'H','e','l','l','o','!','\0'};
//        // 遍历打印字符串数组数组
////        for (int i=0; i<6; i++)
////        {
////            printf("%c",words[i]);
////        }
////        printf("\n");
//        // 字符串数组可以用字符串的方式打印,最后一个元素要是‘\0’
////        printf("%s",words);
//        
//#pragma mark - 二维数组
//        // 2*3数组
//        int arr[2][3] = {{10,20,30},{40,50,60}};
//        int arr2[2][3] = {10,20,30,40,50,60};
//        
//        for(int i=0;i<2;i++)
//        {
//            for (int j=0; j<3; j++)
//            {
//                printf("%d,",arr[i][j]);
//            }
//            printf("\n");
//        }
//        
//        // 练习:
        
//        1)
//        int num[10]={12,24,22,76,34,43,36,23,78,99};
//        int num2[10];
//        // 1)计算总和,计算平均值
//        // 2)找出最大值,找出最小值
          // 3)在数组中找到43(显示它下标是多少)
//        // *4)数组进行从小到大排序放入num2数组中
        
        // 排序
        // 冒泡排序

        // 算法描述
//        比较相邻的元素。如果第一个比第二个大，就交换他们两个。
//        对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
//        针对所有的元素重复以上的步骤，除了最后一个。
//        持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。[
        
        int num[10]={12,24,22,99,76,34,43,36,23,78};
        printf("4、从小到大排序\n");
        
        for (int i=0; i<10; i++)//9轮 排序
        {
            BOOL flag=0;
            for (int j=0; j<10-i-1; j++)
            {
                int t;
                if (num[j]>num[j+1])
                {
                    t=num[j];
                    num[j]=num[j+1];
                    num[j+1]=t;
                    
                    flag = 1;//进行了交换
                }
            }
            
            // 打印一轮计算之后的结果
            printf("第%i轮:",i);
            for (int k=0; k<10; k++)
            {
                printf("%i,",num[k]);
            }
            printf("\n");
            
            if(!flag)// 没有进行任何交换，已经排序完成
            {
                break;
            }
        }
        
        for (int i=0; i<10; i++) {
            printf("%d,",num[i]);
        }
        printf("\n");
        
        //第一轮
        //12,24,22,99,76,34,43,36,23,78
        //12,24,22,76,99,34,43,36,23,78
        //12,24,22,76,34,99,43,36,23,78
        //12,24,22,76,34,43,99,36,23,78
        //12,24,22,76,34,43,36,99,23,78
        //12,24,22,76,34,43,36,23,99,78
        //12,24,22,76,34,43,36,23,79,99
        
//        2)
        //int a[3][4]={{61,72,83,53},{94,15,26,93},{37,48,59,23}};
        //1 计算每行之和并显示
        //2 计算数组总和
        
//        *3) 利用所学的知识制作一个双人五子棋游戏.(提示:用二维数组保存棋盘信息) 0 1 2
        // 规则:五子棋是一种两人对弈的纯策略型棋类游戏，通常双方分别使用黑白两色的棋子，下在棋盘直线与横线的交叉点上，先形成5子连线者获胜。
        // 开始->黑棋下->判断输赢->白棋下->判断输赢->黑棋下->判断输赢->白棋下->判断输赢->...
        // do
        //{
        //   1 某一方下棋
        //     用户输入棋子落点坐标
        //   2 打印
        //   3 判断输赢
        //}while()
        
        // 做题时 分析流程
    
//        **4)利用所学的知识制作一个双人黑白棋游戏。
        // 规则:黑白棋，又叫反棋（Reversi）、奥赛罗棋（Othello）、苹果棋或翻转棋。棋子：黑白棋棋子每颗由黑白两色组成，一面白，一面黑，共64个（包括棋盘中央的4个）。棋子呈圆饼形。
 //        棋盘：黑白棋棋盘由64格的正方格组成，游戏进行时棋子要下在格内。棋盘可分为“角”、“边”以及
//        黑白棋的棋盘是一个有8*8方格的棋盘。下棋时将棋下在空格中间，而不是像围棋一样下在交叉点上。开始时在棋盘正中有两白两黑四个棋子交叉放置，黑棋总是先下子[1]  。

        
//        ⚪️⚫️◻️
        
#pragma mark - 数组与内存
        
//        int num = 9;
//        char c[4] = {'a','b','c','d'};
//        
//        printf("num地址:%p\n",&num);
//        for(int i=0;i<4;i++)
//        {
//            printf("c[%d]的地址:%p\n",i,&c[i]);
//        }
//        printf("\n");
        
//        num地址:0x7fff5fbff83c
//        c[0]的地址:0x7fff5fbff838
//        c[1]的地址:0x7fff5fbff839
//        c[2]的地址:0x7fff5fbff83a
//        c[3]的地址:0x7fff5fbff83b
        
        // 开发中要避免数组下表越界
        char c2[2]={'a','b'};
        char c3[3]={'c','d','e'};

//        c3[0]
//        c3[1]
//        c3[2]
        c3[3] = 'f';
        
        printf("%c,%c\n",c2[0],c2[1]);
        
        


    }
    return 0;
}
